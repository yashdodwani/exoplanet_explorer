<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Dockerfile">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Dockerfile" />
              <option name="originalContent" value="# Use an official Python base image&#10;FROM python:3.12-slim&#10;&#10;# Set environment variables&#10;ENV PYTHONDONTWRITEBYTECODE 1&#10;ENV PYTHONUNBUFFERED 1&#10;&#10;# Set work directory&#10;WORKDIR /app&#10;&#10;# Install system dependencies&#10;RUN apt-get update &amp;&amp; apt-get install -y build-essential &amp;&amp; rm -rf /var/lib/apt/lists/*&#10;&#10;# Copy requirements and install&#10;COPY requirements.txt ./&#10;RUN pip install --upgrade pip &amp;&amp; pip install -r requirements.txt&#10;&#10;# Copy all project files&#10;COPY . .&#10;&#10;# Expose ports for FastAPI (8000) and Streamlit (8501)&#10;EXPOSE 8000 8501&#10;&#10;# Start both FastAPI and Streamlit using a process manager&#10;CMD [&quot;sh&quot;, &quot;-c&quot;, &quot;uvicorn main:app --host 0.0.0.0 --port 8000 &amp; streamlit run frontend.py --server.port 8501 --server.address 0.0.0.0&quot;]&#10;&#10;" />
              <option name="updatedContent" value="# Use an official Python base image&#10;FROM python:3.12-slim&#10;&#10;# Set environment variables&#10;ENV PYTHONDONTWRITEBYTECODE 1&#10;ENV PYTHONUNBUFFERED 1&#10;&#10;# Set work directory&#10;WORKDIR /app&#10;&#10;# Install system dependencies&#10;RUN apt-get update &amp;&amp; apt-get install -y build-essential &amp;&amp; rm -rf /var/lib/apt/lists/*&#10;&#10;# Copy requirements and install&#10;COPY requirements.txt ./&#10;RUN pip install --upgrade pip &amp;&amp; pip install -r requirements.txt&#10;&#10;# Copy all project files&#10;COPY . .&#10;&#10;# Expose only Streamlit port (8501) for public access&#10;EXPOSE 8501&#10;&#10;# Start FastAPI in the background, Streamlit in the foreground&#10;CMD uvicorn main:app --host 0.0.0.0 --port 8000 &amp; \&#10;    streamlit run frontend.py --server.port 8501 --server.address 0.0.0.0" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/frontend.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/frontend.py" />
              <option name="updatedContent" value="import streamlit as st&#10;import pandas as pd&#10;import requests&#10;import io&#10;&#10;st.set_page_config(page_title=&quot;Exoplanet Predictor&quot;, layout=&quot;centered&quot;, page_icon=&quot;&quot;, initial_sidebar_state=&quot;auto&quot;)&#10;&#10;st.markdown(&#10;    &quot;&quot;&quot;&#10;    &lt;style&gt;&#10;    body {&#10;        background-color: #181825;&#10;        color: #e0e0e0;&#10;    }&#10;    .stApp {&#10;        background-color: #181825;&#10;    }&#10;    .css-1d391kg, .css-1v0mbdj, .css-1cpxqw2, .css-1offfwp, .css-1q8dd3e, .css-1lcbmhc {&#10;        background-color: #232136 !important;&#10;        color: #e0e0e0 !important;&#10;    }&#10;    .stButton&gt;button {&#10;        color: #fff;&#10;        background: linear-gradient(90deg, #7f5af0 0%, #232136 100%);&#10;        border: none;&#10;        border-radius: 8px;&#10;        padding: 0.5em 2em;&#10;        font-weight: bold;&#10;    }&#10;    .stFileUploader&gt;div&gt;div {&#10;        background: #232136;&#10;        color: #e0e0e0;&#10;    }&#10;    &lt;/style&gt;&#10;    &quot;&quot;&quot;,&#10;    unsafe_allow_html=True&#10;)&#10;&#10;st.title(&quot; Exoplanet Disposition Predictor&quot;)&#10;&#10;st.markdown(&quot;&quot;&quot;&#10;Upload a CSV file or enter the features for a single exoplanet candidate below to predict its disposition (CONFIRMED, CANDIDATE, FALSE POSITIVE).&#10;&quot;&quot;&quot;)&#10;&#10;API_URL = &quot;http://localhost:8000&quot;&#10;&#10;with st.expander(&quot; Predict for a single exoplanet candidate&quot;):&#10;    with st.form(&quot;single_form&quot;):&#10;        # All features except koi_disposition and relative error columns&#10;        koi_score = st.number_input(&quot;koi_score&quot;, value=0.0, format=&quot;%f&quot;)&#10;        koi_period = st.number_input(&quot;koi_period&quot;, value=0.0, format=&quot;%f&quot;)&#10;        koi_eccen = st.number_input(&quot;koi_eccen&quot;, value=0.0, format=&quot;%f&quot;)&#10;        koi_impact = st.number_input(&quot;koi_impact&quot;, value=0.0, format=&quot;%f&quot;)&#10;        koi_duration = st.number_input(&quot;koi_duration&quot;, value=0.0, format=&quot;%f&quot;)&#10;        koi_depth = st.number_input(&quot;koi_depth&quot;, value=0.0, format=&quot;%f&quot;)&#10;        koi_ror = st.number_input(&quot;koi_ror&quot;, value=0.0, format=&quot;%f&quot;)&#10;        koi_srho = st.number_input(&quot;koi_srho&quot;, value=0.0, format=&quot;%f&quot;)&#10;        koi_incl = st.number_input(&quot;koi_incl&quot;, value=0.0, format=&quot;%f&quot;)&#10;        koi_teq = st.number_input(&quot;koi_teq&quot;, value=0.0, format=&quot;%f&quot;)&#10;        koi_insol = st.number_input(&quot;koi_insol&quot;, value=0.0, format=&quot;%f&quot;)&#10;        koi_dor = st.number_input(&quot;koi_dor&quot;, value=0.0, format=&quot;%f&quot;)&#10;        koi_model_snr = st.number_input(&quot;koi_model_snr&quot;, value=0.0, format=&quot;%f&quot;)&#10;        koi_count = st.number_input(&quot;koi_count&quot;, value=0.0, format=&quot;%f&quot;)&#10;        koi_num_transits = st.number_input(&quot;koi_num_transits&quot;, value=0.0, format=&quot;%f&quot;)&#10;        koi_steff = st.number_input(&quot;koi_steff&quot;, value=0.0, format=&quot;%f&quot;)&#10;        koi_slogg = st.number_input(&quot;koi_slogg&quot;, value=0.0, format=&quot;%f&quot;)&#10;        koi_smet = st.number_input(&quot;koi_smet&quot;, value=0.0, format=&quot;%f&quot;)&#10;        koi_smass = st.number_input(&quot;koi_smass&quot;, value=0.0, format=&quot;%f&quot;)&#10;        ra = st.number_input(&quot;ra&quot;, value=0.0, format=&quot;%f&quot;)&#10;        dec = st.number_input(&quot;dec&quot;, value=0.0, format=&quot;%f&quot;)&#10;        koi_kepmag = st.number_input(&quot;koi_kepmag&quot;, value=0.0, format=&quot;%f&quot;)&#10;        koi_gmag = st.number_input(&quot;koi_gmag&quot;, value=0.0, format=&quot;%f&quot;)&#10;        koi_rmag = st.number_input(&quot;koi_rmag&quot;, value=0.0, format=&quot;%f&quot;)&#10;        koi_imag = st.number_input(&quot;koi_imag&quot;, value=0.0, format=&quot;%f&quot;)&#10;        koi_zmag = st.number_input(&quot;koi_zmag&quot;, value=0.0, format=&quot;%f&quot;)&#10;        koi_jmag = st.number_input(&quot;koi_jmag&quot;, value=0.0, format=&quot;%f&quot;)&#10;        koi_hmag = st.number_input(&quot;koi_hmag&quot;, value=0.0, format=&quot;%f&quot;)&#10;        koi_kmag = st.number_input(&quot;koi_kmag&quot;, value=0.0, format=&quot;%f&quot;)&#10;        loc_rowid = st.number_input(&quot;loc_rowid&quot;, value=0.0, format=&quot;%f&quot;)&#10;        st_pmra = st.number_input(&quot;st_pmra&quot;, value=0.0, format=&quot;%f&quot;)&#10;        st_pmdec = st.number_input(&quot;st_pmdec&quot;, value=0.0, format=&quot;%f&quot;)&#10;        pl_tranmid = st.number_input(&quot;pl_tranmid&quot;, value=0.0, format=&quot;%f&quot;)&#10;        koi_prad = st.number_input(&quot;koi_prad&quot;, value=0.0, format=&quot;%f&quot;)&#10;        koi_tmag = st.number_input(&quot;koi_tmag&quot;, value=0.0, format=&quot;%f&quot;)&#10;        st_dist = st.number_input(&quot;st_dist&quot;, value=0.0, format=&quot;%f&quot;)&#10;        koi_srad = st.number_input(&quot;koi_srad&quot;, value=0.0, format=&quot;%f&quot;)&#10;        koi_fittype_LS_MCMC = st.number_input(&quot;koi_fittype_LS_MCMC&quot;, value=0.0, format=&quot;%f&quot;)&#10;        koi_fittype_MCMC = st.number_input(&quot;koi_fittype_MCMC&quot;, value=0.0, format=&quot;%f&quot;)&#10;        koi_fittype_none = st.number_input(&quot;koi_fittype_none&quot;, value=0.0, format=&quot;%f&quot;)&#10;        submitted = st.form_submit_button(&quot;Predict&quot;)&#10;        if submitted:&#10;            payload = {&#10;                &quot;koi_score&quot;: koi_score,&#10;                &quot;koi_period&quot;: koi_period,&#10;                &quot;koi_eccen&quot;: koi_eccen,&#10;                &quot;koi_impact&quot;: koi_impact,&#10;                &quot;koi_duration&quot;: koi_duration,&#10;                &quot;koi_depth&quot;: koi_depth,&#10;                &quot;koi_ror&quot;: koi_ror,&#10;                &quot;koi_srho&quot;: koi_srho,&#10;                &quot;koi_incl&quot;: koi_incl,&#10;                &quot;koi_teq&quot;: koi_teq,&#10;                &quot;koi_insol&quot;: koi_insol,&#10;                &quot;koi_dor&quot;: koi_dor,&#10;                &quot;koi_model_snr&quot;: koi_model_snr,&#10;                &quot;koi_count&quot;: koi_count,&#10;                &quot;koi_num_transits&quot;: koi_num_transits,&#10;                &quot;koi_steff&quot;: koi_steff,&#10;                &quot;koi_slogg&quot;: koi_slogg,&#10;                &quot;koi_smet&quot;: koi_smet,&#10;                &quot;koi_smass&quot;: koi_smass,&#10;                &quot;ra&quot;: ra,&#10;                &quot;dec&quot;: dec,&#10;                &quot;koi_kepmag&quot;: koi_kepmag,&#10;                &quot;koi_gmag&quot;: koi_gmag,&#10;                &quot;koi_rmag&quot;: koi_rmag,&#10;                &quot;koi_imag&quot;: koi_imag,&#10;                &quot;koi_zmag&quot;: koi_zmag,&#10;                &quot;koi_jmag&quot;: koi_jmag,&#10;                &quot;koi_hmag&quot;: koi_hmag,&#10;                &quot;koi_kmag&quot;: koi_kmag,&#10;                &quot;loc_rowid&quot;: loc_rowid,&#10;                &quot;st_pmra&quot;: st_pmra,&#10;                &quot;st_pmdec&quot;: st_pmdec,&#10;                &quot;pl_tranmid&quot;: pl_tranmid,&#10;                &quot;koi_prad&quot;: koi_prad,&#10;                &quot;koi_tmag&quot;: koi_tmag,&#10;                &quot;st_dist&quot;: st_dist,&#10;                &quot;koi_srad&quot;: koi_srad,&#10;                &quot;koi_fittype_LS_MCMC&quot;: koi_fittype_LS_MCMC,&#10;                &quot;koi_fittype_MCMC&quot;: koi_fittype_MCMC,&#10;                &quot;koi_fittype_none&quot;: koi_fittype_none&#10;            }&#10;            try:&#10;                response = requests.post(f&quot;{API_URL}/predict&quot;, json=payload)&#10;                if response.status_code == 200:&#10;                    st.success(f&quot;Prediction: {response.json()['prediction']}&quot;)&#10;                else:&#10;                    st.error(f&quot;Error: {response.text}&quot;)&#10;            except Exception as e:&#10;                st.error(f&quot;Request failed: {e}&quot;)&#10;&#10;st.markdown(&quot;---&quot;)&#10;&#10;with st.expander(&quot; Predict for a batch (CSV upload)&quot;):&#10;    uploaded_file = st.file_uploader(&quot;Upload CSV file with the required columns&quot;, type=[&quot;csv&quot;])&#10;    if uploaded_file is not None:&#10;        if st.button(&quot;Predict for CSV&quot;):&#10;            try:&#10;                files = {&quot;file&quot;: uploaded_file.getvalue()}&#10;                response = requests.post(f&quot;{API_URL}/predict_csv&quot;, files={&quot;file&quot;: (uploaded_file.name, uploaded_file, &quot;text/csv&quot;)})&#10;                if response.status_code == 200:&#10;                    st.success(&quot;Prediction complete! Download your results below.&quot;)&#10;                    st.download_button(&#10;                        label=&quot;Download Predicted CSV&quot;,&#10;                        data=response.content,&#10;                        file_name=&quot;predicted_exoplanets.csv&quot;,&#10;                        mime=&quot;text/csv&quot;&#10;                    )&#10;                else:&#10;                    st.error(f&quot;Error: {response.text}&quot;)&#10;            except Exception as e:&#10;                st.error(f&quot;Request failed: {e}&quot;)&#10;&#10;st.markdown(&quot;&quot;&quot;&#10;&lt;style&gt;&#10;footer {visibility: hidden;}&#10;&lt;/style&gt;&#10;&quot;&quot;&quot;, unsafe_allow_html=True)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/main.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/main.py" />
              <option name="originalContent" value="from fastapi import FastAPI, APIRouter, UploadFile, File, Body&#10;from pydantic import BaseModel&#10;import joblib&#10;import numpy as np&#10;import pandas as pd&#10;import io&#10;from fastapi.responses import StreamingResponse&#10;&#10;app = FastAPI()&#10;router = APIRouter()&#10;&#10;# Load the model and label encoder&#10;model = joblib.load(&quot;LightGBM_exoplanet_model.pkl&quot;)&#10;&#10;# For now, let's assume the classes are known (update as needed)&#10;label_classes = ['APC', 'CANDIDATE', 'CONFIRMED', 'FALSE POSITIVE']&#10;&#10;# List of all features except koi_disposition and the relative error columns&#10;feature_names = [&#10;    'koi_score','koi_period','koi_eccen','koi_impact','koi_duration','koi_depth','koi_ror','koi_srho','koi_incl','koi_teq','koi_insol','koi_dor','koi_model_snr','koi_count','koi_num_transits','koi_steff','koi_slogg','koi_smet','koi_smass','ra','dec','koi_kepmag','koi_gmag','koi_rmag','koi_imag','koi_zmag','koi_jmag','koi_hmag','koi_kmag','loc_rowid','st_pmra','st_pmdec','pl_tranmid','koi_prad','koi_tmag','st_dist','koi_srad','koi_fittype_LS+MCMC','koi_fittype_MCMC','koi_fittype_none'&#10;]&#10;&#10;class ExoplanetInput(BaseModel):&#10;    koi_score: float&#10;    koi_period: float&#10;    koi_eccen: float&#10;    koi_impact: float&#10;    koi_duration: float&#10;    koi_depth: float&#10;    koi_ror: float&#10;    koi_srho: float&#10;    koi_incl: float&#10;    koi_teq: float&#10;    koi_insol: float&#10;    koi_dor: float&#10;    koi_model_snr: float&#10;    koi_count: float&#10;    koi_num_transits: float&#10;    koi_steff: float&#10;    koi_slogg: float&#10;    koi_smet: float&#10;    koi_smass: float&#10;    ra: float&#10;    dec: float&#10;    koi_kepmag: float&#10;    koi_gmag: float&#10;    koi_rmag: float&#10;    koi_imag: float&#10;    koi_zmag: float&#10;    koi_jmag: float&#10;    koi_hmag: float&#10;    koi_kmag: float&#10;    loc_rowid: float&#10;    st_pmra: float&#10;    st_pmdec: float&#10;    pl_tranmid: float&#10;    koi_prad: float&#10;    koi_tmag: float&#10;    st_dist: float&#10;    koi_srad: float&#10;    koi_fittype_LS_MCMC: float&#10;    koi_fittype_MCMC: float&#10;    koi_fittype_none: float&#10;&#10;# Try to load the label encoder if available&#10;try:&#10;    le = joblib.load(&quot;label_encoder.pkl&quot;)&#10;    def decode_label(idx):&#10;        return le.inverse_transform([int(idx)])[0]&#10;except Exception:&#10;    label_classes = ['APC', 'CANDIDATE', 'CONFIRMED', 'FALSE POSITIVE']&#10;    def decode_label(idx):&#10;        return label_classes[int(idx)]&#10;&#10;# Load the feature list used for training&#10;try:&#10;    training_features = joblib.load(&quot;features.pkl&quot;)&#10;except Exception:&#10;    training_features = feature_names  # fallback, but may cause errors if not matching&#10;&#10;@router.post(&quot;/predict&quot;)&#10;def predict_exoplanet(data: ExoplanetInput):&#10;    # Convert input to DataFrame&#10;    input_df = pd.DataFrame([data.dict()])&#10;    # Fix column name for koi_fittype_LS+MCMC&#10;    if 'koi_fittype_LS_MCMC' in input_df.columns:&#10;        input_df = input_df.rename(columns={'koi_fittype_LS_MCMC': 'koi_fittype_LS+MCMC'})&#10;    # Predict&#10;    pred = model.predict(input_df)&#10;    # Convert prediction to string label&#10;    pred_label = decode_label(pred[0])&#10;    return {&quot;prediction&quot;: pred_label}&#10;&#10;@router.post(&quot;/predict_csv&quot;)&#10;def predict_exoplanet_csv(file: UploadFile = File(...)):&#10;    df = pd.read_csv(file.file)&#10;    # Strip whitespace from column names&#10;    df.columns = df.columns.str.strip()&#10;    # Debug: print/log received and expected columns&#10;    print(&quot;Received columns:&quot;, list(df.columns))&#10;    print(&quot;Expected columns:&quot;, list(training_features))&#10;    # Reindex to match training features, fill missing with 0&#10;    df = df.reindex(columns=training_features, fill_value=0)&#10;    preds = model.predict(df)&#10;    pred_labels = [decode_label(idx) for idx in preds]&#10;    df['prediction'] = pred_labels&#10;    output = io.StringIO()&#10;    df.to_csv(output, index=False)&#10;    output.seek(0)&#10;    return StreamingResponse(output, media_type=&quot;text/csv&quot;, headers={&quot;Content-Disposition&quot;: &quot;attachment; filename=predicted_exoplanets.csv&quot;})&#10;&#10;@router.post(&quot;/encode_label&quot;)&#10;def encode_label(label: str = Body(..., embed=True)):&#10;    try:&#10;        encoded = int(le.transform([label])[0])&#10;        return {&quot;encoded&quot;: encoded}&#10;    except Exception as e:&#10;        return {&quot;error&quot;: str(e)}&#10;&#10;@router.post(&quot;/decode_label&quot;)&#10;def decode_label_api(encoded: int = Body(..., embed=True)):&#10;    try:&#10;        decoded = str(le.inverse_transform([encoded])[0])&#10;        return {&quot;label&quot;: decoded}&#10;    except Exception as e:&#10;        return {&quot;error&quot;: str(e)}&#10;&#10;app.include_router(router)&#10;" />
              <option name="updatedContent" value="from fastapi import FastAPI, APIRouter, UploadFile, File, Body&#10;from pydantic import BaseModel&#10;import joblib&#10;import numpy as np&#10;import pandas as pd&#10;import io&#10;from fastapi.responses import StreamingResponse&#10;&#10;app = FastAPI()&#10;router = APIRouter()&#10;&#10;# Load the model and label encoder&#10;model = joblib.load(&quot;LightGBM_exoplanet_model.pkl&quot;)&#10;&#10;# For now, let's assume the classes are known (update as needed)&#10;label_classes = ['APC', 'CANDIDATE', 'CONFIRMED', 'FALSE POSITIVE']&#10;&#10;# List of all features except koi_disposition and the relative error columns&#10;feature_names = [&#10;    'koi_score','koi_period','koi_eccen','koi_impact','koi_duration','koi_depth','koi_ror','koi_srho','koi_incl','koi_teq','koi_insol','koi_dor','koi_model_snr','koi_count','koi_num_transits','koi_steff','koi_slogg','koi_smet','koi_smass','ra','dec','koi_kepmag','koi_gmag','koi_rmag','koi_imag','koi_zmag','koi_jmag','koi_hmag','koi_kmag','loc_rowid','st_pmra','st_pmdec','pl_tranmid','koi_prad','koi_tmag','st_dist','koi_srad','koi_fittype_LS+MCMC','koi_fittype_MCMC','koi_fittype_none'&#10;]&#10;&#10;class ExoplanetInput(BaseModel):&#10;    koi_score: float&#10;    koi_period: float&#10;    koi_eccen: float&#10;    koi_impact: float&#10;    koi_duration: float&#10;    koi_depth: float&#10;    koi_ror: float&#10;    koi_srho: float&#10;    koi_incl: float&#10;    koi_teq: float&#10;    koi_insol: float&#10;    koi_dor: float&#10;    koi_model_snr: float&#10;    koi_count: float&#10;    koi_num_transits: float&#10;    koi_steff: float&#10;    koi_slogg: float&#10;    koi_smet: float&#10;    koi_smass: float&#10;    ra: float&#10;    dec: float&#10;    koi_kepmag: float&#10;    koi_gmag: float&#10;    koi_rmag: float&#10;    koi_imag: float&#10;    koi_zmag: float&#10;    koi_jmag: float&#10;    koi_hmag: float&#10;    koi_kmag: float&#10;    loc_rowid: float&#10;    st_pmra: float&#10;    st_pmdec: float&#10;    pl_tranmid: float&#10;    koi_prad: float&#10;    koi_tmag: float&#10;    st_dist: float&#10;    koi_srad: float&#10;    koi_fittype_LS_MCMC: float&#10;    koi_fittype_MCMC: float&#10;    koi_fittype_none: float&#10;&#10;# Try to load the label encoder if available&#10;try:&#10;    le = joblib.load(&quot;label_encoder.pkl&quot;)&#10;    def decode_label(idx):&#10;        return le.inverse_transform([int(idx)])[0]&#10;except Exception:&#10;    label_classes = ['APC', 'CANDIDATE', 'CONFIRMED', 'FALSE POSITIVE']&#10;    def decode_label(idx):&#10;        return label_classes[int(idx)]&#10;&#10;# Load the feature list used for training&#10;try:&#10;    training_features = joblib.load(&quot;features.pkl&quot;)&#10;except Exception:&#10;    training_features = feature_names  # fallback, but may cause errors if not matching&#10;&#10;@router.post(&quot;/predict&quot;)&#10;def predict_exoplanet(data: ExoplanetInput):&#10;    # Convert input to DataFrame&#10;    input_df = pd.DataFrame([data.dict()])&#10;    # Fix column name for koi_fittype_LS+MCMC&#10;    if 'koi_fittype_LS_MCMC' in input_df.columns:&#10;        input_df = input_df.rename(columns={'koi_fittype_LS_MCMC': 'koi_fittype_LS+MCMC'})&#10;    # Predict&#10;    pred = model.predict(input_df)&#10;    # Convert prediction to string label&#10;    pred_label = decode_label(pred[0])&#10;    return {&quot;prediction&quot;: pred_label}&#10;&#10;@router.post(&quot;/predict_csv&quot;)&#10;def predict_exoplanet_csv(file: UploadFile = File(...)):&#10;    df = pd.read_csv(file.file)&#10;    df.columns = df.columns.str.strip()&#10;    print(&quot;Received columns ({}):&quot;.format(len(df.columns)), list(df.columns))&#10;    print(&quot;Expected columns ({}):&quot;.format(len(training_features)), list(training_features))&#10;    missing = [col for col in training_features if col not in df.columns]&#10;    extra = [col for col in df.columns if col not in training_features]&#10;    print(&quot;Missing columns:&quot;, missing)&#10;    print(&quot;Extra columns:&quot;, extra)&#10;    # Reindex to match training features, fill missing with 0&#10;    df = df.reindex(columns=training_features, fill_value=0)&#10;    print(&quot;DataFrame shape after reindex:&quot;, df.shape)&#10;    print(&quot;DataFrame columns after reindex:&quot;, list(df.columns))&#10;    preds = model.predict(df)&#10;    pred_labels = [decode_label(idx) for idx in preds]&#10;    df['prediction'] = pred_labels&#10;    output = io.StringIO()&#10;    df.to_csv(output, index=False)&#10;    output.seek(0)&#10;    return StreamingResponse(output, media_type=&quot;text/csv&quot;, headers={&quot;Content-Disposition&quot;: &quot;attachment; filename=predicted_exoplanets.csv&quot;})&#10;&#10;@router.post(&quot;/encode_label&quot;)&#10;def encode_label(label: str = Body(..., embed=True)):&#10;    try:&#10;        encoded = int(le.transform([label])[0])&#10;        return {&quot;encoded&quot;: encoded}&#10;    except Exception as e:&#10;        return {&quot;error&quot;: str(e)}&#10;&#10;@router.post(&quot;/decode_label&quot;)&#10;def decode_label_api(encoded: int = Body(..., embed=True)):&#10;    try:&#10;        decoded = str(le.inverse_transform([encoded])[0])&#10;        return {&quot;label&quot;: decoded}&#10;    except Exception as e:&#10;        return {&quot;error&quot;: str(e)}&#10;&#10;app.include_router(router)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/model.ipynb">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/model.ipynb" />
              <option name="originalContent" value="#%%&#10;from sklearn.model_selection import StratifiedKFold, cross_val_score, train_test_split&#10;from sklearn.metrics import accuracy_score, f1_score, classification_report, confusion_matrix&#10;from catboost import CatBoostClassifier&#10;from lightgbm import LGBMClassifier&#10;import matplotlib.pyplot as plt&#10;import numpy as np&#10;import pandas as pd&#10;#%%&#10;df = pd.read_csv('grand_dAAAAAAaataset_final_scaled.csv')&#10;#%%&#10; df.info()&#10;#%%&#10;from sklearn.preprocessing import LabelEncoder&#10;le = LabelEncoder()&#10;#%%&#10;y = le.fit_transform(df[&quot;koi_disposition&quot;])&#10;X = df.drop(&quot;koi_disposition&quot;, axis=1)&#10;#%%&#10;for idx, label in enumerate(le.classes_):&#10;    print(f&quot;{idx}: {label}&quot;)&#10;#%%&#10;df.info()&#10;#%%&#10;from sklearn.model_selection import train_test_split&#10;X_train, X_test, y_train, y_test = train_test_split(&#10;    X, y, test_size=0.2, stratify=y, random_state=42&#10;)&#10;#%%&#10;cat_model = CatBoostClassifier(&#10;    iterations=800, learning_rate=0.05, depth=8,&#10;    loss_function='MultiClass', verbose=0&#10;)&#10;&#10;lgbm_model = LGBMClassifier(&#10;    n_estimators=800, learning_rate=0.05, max_depth=8,&#10;    objective='multiclass', random_state=42&#10;)&#10;&#10;models = {&#10;    &quot;CatBoost&quot;: cat_model,&#10;    &quot;LightGBM&quot;: lgbm_model&#10;}&#10;#%%&#10;&#10;#%%&#10;skf = StratifiedKFold(n_splits=5, shuffle=True, random_state=42)&#10;&#10;results = {}&#10;for name, model in models.items():&#10;    print(f&quot;\n Cross-validating {name}...&quot;)&#10;    acc_scores = cross_val_score(model, X_train, y_train, cv=skf, scoring='accuracy')&#10;    f1_scores = cross_val_score(model, X_train, y_train, cv=skf, scoring='f1_macro')&#10;    results[name] = {&#10;        &quot;Accuracy Mean&quot;: acc_scores.mean(),&#10;        &quot;F1 Macro Mean&quot;: f1_scores.mean()&#10;    }&#10;    print(f&quot;Accuracy: {acc_scores.mean():.4f} | F1-Macro: {f1_scores.mean():.4f}&quot;)&#10;#%%&#10;&#10;#%%&#10;best_model_name = max(results, key=lambda x: results[x]['F1 Macro Mean'])&#10;best_model = models[best_model_name]&#10;print(f&quot;\n Best Model based on CV: {best_model_name}&quot;)&#10;#%%&#10;#fit the best model on the entire training set&#10;best_model.fit(X_train, y_train)&#10;#%%&#10;y_pred = best_model.predict(X_test)&#10;print(&quot;\nClassification Report:&quot;)&#10;print(classification_report(y_test, y_pred))&#10;print(&quot;\nConfusion Matrix:&quot;)&#10;print(confusion_matrix(y_test, y_pred))&#10;#%%&#10;decoded_preds = le.inverse_transform(y_pred.astype(int))&#10;print(decoded_preds)&#10;#%%&#10;#Feature Importance Visualization&#10;importance = best_model.feature_importances_&#10;features = X.columns&#10;fi = pd.DataFrame({&quot;Feature&quot;: features, &quot;Importance&quot;: importance}).sort_values(by=&quot;Importance&quot;, ascending=False)&#10;plt.figure(figsize=(10, 6))&#10;plt.barh(fi[&quot;Feature&quot;].head(15)[::-1], fi[&quot;Importance&quot;].head(15)[::-1])&#10;plt.title(f&quot;Top 15 Feature Importances - {best_model_name}&quot;)&#10;plt.show()&#10;#%%&#10;# Create a new DataFrame df2 without the relative error columns&#10;relative_error_cols = [&#10;    'Relative_Error_PLANET_ORBPER',&#10;    'Relative_Error_PLANET_RADE',&#10;    'Relative_Error_PLANET_TRANDEP',&#10;    'Relative_Error_PLANET_TRANDURH',&#10;    'Relative_Error_PLANET_TRANMID',&#10;    'Relative_Error_STAR_DIST',&#10;    'Relative_Error_STAR_LOGG',&#10;    'Relative_Error_STAR_PMDEC',&#10;    'Relative_Error_STAR_PMRA',&#10;    'Relative_Error_STAR_RAD',&#10;    'Relative_Error_STAR_TEFF',&#10;    'Relative_Error_STAR_TMAG'&#10;]&#10;df2 = df.drop(columns=relative_error_cols)&#10;&#10;#%%&#10;# Label encode target for df2&#10;le2 = LabelEncoder()&#10;y2 = le2.fit_transform(df2[&quot;koi_disposition&quot;])&#10;X2 = df2.drop(&quot;koi_disposition&quot;, axis=1)&#10;&#10;#%%&#10;# Train/test split for df2&#10;X2_train, X2_test, y2_train, y2_test = train_test_split(&#10;    X2, y2, test_size=0.2, stratify=y2, random_state=42&#10;)&#10;&#10;#%%&#10;# Reuse the same models for df2&#10;results2 = {}&#10;skf2 = StratifiedKFold(n_splits=5, shuffle=True, random_state=42)&#10;for name, model in models.items():&#10;    print(f&quot;\n Cross-validating {name} (df2)...&quot;)&#10;    acc_scores = cross_val_score(model, X2_train, y2_train, cv=skf2, scoring='accuracy')&#10;    f1_scores = cross_val_score(model, X2_train, y2_train, cv=skf2, scoring='f1_macro')&#10;    results2[name] = {&#10;        &quot;Accuracy Mean&quot;: acc_scores.mean(),&#10;        &quot;F1 Macro Mean&quot;: f1_scores.mean()&#10;    }&#10;    print(f&quot;Accuracy: {acc_scores.mean():.4f} | F1-Macro: {f1_scores.mean():.4f}&quot;)&#10;&#10;#%%&#10;import joblib&#10;joblib.dump(best_model, f&quot;{best_model_name}_exoplanet_model.pkl&quot;)&#10;#%%&#10;&#10;#%%&#10;import joblib&#10;print(list(X.columns))" />
              <option name="updatedContent" value="#%%&#10;from sklearn.model_selection import StratifiedKFold, cross_val_score, train_test_split&#10;from sklearn.metrics import accuracy_score, f1_score, classification_report, confusion_matrix&#10;from catboost import CatBoostClassifier&#10;from lightgbm import LGBMClassifier&#10;import matplotlib.pyplot as plt&#10;import numpy as np&#10;import pandas as pd&#10;#%%&#10;df = pd.read_csv('grand_dAAAAAAaataset_final_scaled.csv')&#10;#%%&#10; df.info()&#10;#%%&#10;from sklearn.preprocessing import LabelEncoder&#10;le = LabelEncoder()&#10;#%%&#10;y = le.fit_transform(df[&quot;koi_disposition&quot;])&#10;X = df.drop(&quot;koi_disposition&quot;, axis=1)&#10;#%%&#10;for idx, label in enumerate(le.classes_):&#10;    print(f&quot;{idx}: {label}&quot;)&#10;#%%&#10;df.info()&#10;#%%&#10;from sklearn.model_selection import train_test_split&#10;X_train, X_test, y_train, y_test = train_test_split(&#10;    X, y, test_size=0.2, stratify=y, random_state=42&#10;)&#10;#%%&#10;cat_model = CatBoostClassifier(&#10;    iterations=800, learning_rate=0.05, depth=8,&#10;    loss_function='MultiClass', verbose=0&#10;)&#10;&#10;lgbm_model = LGBMClassifier(&#10;    n_estimators=800, learning_rate=0.05, max_depth=8,&#10;    objective='multiclass', random_state=42&#10;)&#10;&#10;models = {&#10;    &quot;CatBoost&quot;: cat_model,&#10;    &quot;LightGBM&quot;: lgbm_model&#10;}&#10;#%%&#10;&#10;#%%&#10;skf = StratifiedKFold(n_splits=5, shuffle=True, random_state=42)&#10;&#10;results = {}&#10;for name, model in models.items():&#10;    print(f&quot;\n Cross-validating {name}...&quot;)&#10;    acc_scores = cross_val_score(model, X_train, y_train, cv=skf, scoring='accuracy')&#10;    f1_scores = cross_val_score(model, X_train, y_train, cv=skf, scoring='f1_macro')&#10;    results[name] = {&#10;        &quot;Accuracy Mean&quot;: acc_scores.mean(),&#10;        &quot;F1 Macro Mean&quot;: f1_scores.mean()&#10;    }&#10;    print(f&quot;Accuracy: {acc_scores.mean():.4f} | F1-Macro: {f1_scores.mean():.4f}&quot;)&#10;#%%&#10;&#10;#%%&#10;best_model_name = max(results, key=lambda x: results[x]['F1 Macro Mean'])&#10;best_model = models[best_model_name]&#10;print(f&quot;\n Best Model based on CV: {best_model_name}&quot;)&#10;#%%&#10;#fit the best model on the entire training set&#10;best_model.fit(X_train, y_train)&#10;#%%&#10;y_pred = best_model.predict(X_test)&#10;print(&quot;\nClassification Report:&quot;)&#10;print(classification_report(y_test, y_pred))&#10;print(&quot;\nConfusion Matrix:&quot;)&#10;print(confusion_matrix(y_test, y_pred))&#10;#%%&#10;decoded_preds = le.inverse_transform(y_pred.astype(int))&#10;print(decoded_preds)&#10;#%%&#10;#Feature Importance Visualization&#10;importance = best_model.feature_importances_&#10;features = X.columns&#10;fi = pd.DataFrame({&quot;Feature&quot;: features, &quot;Importance&quot;: importance}).sort_values(by=&quot;Importance&quot;, ascending=False)&#10;plt.figure(figsize=(10, 6))&#10;plt.barh(fi[&quot;Feature&quot;].head(15)[::-1], fi[&quot;Importance&quot;].head(15)[::-1])&#10;plt.title(f&quot;Top 15 Feature Importances - {best_model_name}&quot;)&#10;plt.show()&#10;#%%&#10;# Create a new DataFrame df2 without the relative error columns&#10;relative_error_cols = [&#10;    'Relative_Error_PLANET_ORBPER',&#10;    'Relative_Error_PLANET_RADE',&#10;    'Relative_Error_PLANET_TRANDEP',&#10;    'Relative_Error_PLANET_TRANDURH',&#10;    'Relative_Error_PLANET_TRANMID',&#10;    'Relative_Error_STAR_DIST',&#10;    'Relative_Error_STAR_LOGG',&#10;    'Relative_Error_STAR_PMDEC',&#10;    'Relative_Error_STAR_PMRA',&#10;    'Relative_Error_STAR_RAD',&#10;    'Relative_Error_STAR_TEFF',&#10;    'Relative_Error_STAR_TMAG'&#10;]&#10;df2 = df.drop(columns=relative_error_cols)&#10;&#10;#%%&#10;# Label encode target for df2&#10;le2 = LabelEncoder()&#10;y2 = le2.fit_transform(df2[&quot;koi_disposition&quot;])&#10;X2 = df2.drop(&quot;koi_disposition&quot;, axis=1)&#10;&#10;#%%&#10;# Train/test split for df2&#10;X2_train, X2_test, y2_train, y2_test = train_test_split(&#10;    X2, y2, test_size=0.2, stratify=y2, random_state=42&#10;)&#10;&#10;#%%&#10;# Reuse the same models for df2&#10;results2 = {}&#10;skf2 = StratifiedKFold(n_splits=5, shuffle=True, random_state=42)&#10;for name, model in models.items():&#10;    print(f&quot;\n Cross-validating {name} (df2)...&quot;)&#10;    acc_scores = cross_val_score(model, X2_train, y2_train, cv=skf2, scoring='accuracy')&#10;    f1_scores = cross_val_score(model, X2_train, y2_train, cv=skf2, scoring='f1_macro')&#10;    results2[name] = {&#10;        &quot;Accuracy Mean&quot;: acc_scores.mean(),&#10;        &quot;F1 Macro Mean&quot;: f1_scores.mean()&#10;    }&#10;    print(f&quot;Accuracy: {acc_scores.mean():.4f} | F1-Macro: {f1_scores.mean():.4f}&quot;)&#10;&#10;#%%&#10;import joblib&#10;joblib.dump(best_model, f&quot;{best_model_name}_exoplanet_model.pkl&quot;)&#10;#%%&#10;&#10;#%%&#10;import joblib&#10;print(list(X.columns))&#10;#%%&#10;# Save the fitted LabelEncoder and feature list for API/testing use&#10;import joblib&#10;joblib.dump(le, &quot;label_encoder.pkl&quot;)&#10;joblib.dump(list(X.columns), &quot;features.pkl&quot;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/requirements.txt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/requirements.txt" />
              <option name="originalContent" value="streamlit&#10;pandas&#10;requests&#10;fastapi&#10;uvicorn&#10;joblib&#10;lightgbm&#10;catboost&#10;scikit-learn&#10;numpy" />
              <option name="updatedContent" value="streamlit&#10;pandas&#10;requests&#10;fastapi&#10;uvicorn&#10;joblib&#10;lightgbm&#10;catboost&#10;scikit-learn&#10;numpy&#10;matplotlib&#10;seaborn" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/test_model.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/test_model.py" />
              <option name="updatedContent" value="import pytest&#10;import joblib&#10;import numpy as np&#10;import pandas as pd&#10;&#10;# Load model and label encoder&#10;model = joblib.load(&quot;LightGBM_exoplanet_model.pkl&quot;)&#10;le = joblib.load(&quot;label_encoder.pkl&quot;)&#10;features = joblib.load(&quot;features.pkl&quot;)&#10;&#10;def test_model_on_custom_input():&#10;    # Example custom input (fill with realistic values or zeros for demo)&#10;    custom_input = {&#10;        'koi_score': 0.5,&#10;        'koi_period': 1.0,&#10;        'koi_eccen': 0.0,&#10;        'koi_impact': 0.1,&#10;        'koi_duration': 2.0,&#10;        'koi_depth': 0.01,&#10;        'koi_ror': 0.2,&#10;        'koi_srho': 1.0,&#10;        'koi_incl': 89.0,&#10;        'koi_teq': 500.0,&#10;        'koi_insol': 1.0,&#10;        'koi_dor': 10.0,&#10;        'koi_model_snr': 20.0,&#10;        'koi_count': 1.0,&#10;        'koi_num_transits': 3.0,&#10;        'koi_steff': 5700.0,&#10;        'koi_slogg': 4.4,&#10;        'koi_smet': 0.0,&#10;        'koi_smass': 1.0,&#10;        'ra': 290.0,&#10;        'dec': 44.0,&#10;        'koi_kepmag': 12.0,&#10;        'koi_gmag': 13.0,&#10;        'koi_rmag': 13.0,&#10;        'koi_imag': 13.0,&#10;        'koi_zmag': 13.0,&#10;        'koi_jmag': 12.0,&#10;        'koi_hmag': 12.0,&#10;        'koi_kmag': 12.0,&#10;        'loc_rowid': 1.0,&#10;        'st_pmra': 0.0,&#10;        'st_pmdec': 0.0,&#10;        'pl_tranmid': 0.0,&#10;        'koi_prad': 1.0,&#10;        'koi_tmag': 12.0,&#10;        'st_dist': 100.0,&#10;        'koi_srad': 1.0,&#10;        'Relative_Error_PLANET_ORBPER': 0.0,&#10;        'Relative_Error_PLANET_RADE': 0.0,&#10;        'Relative_Error_PLANET_TRANDEP': 0.0,&#10;        'Relative_Error_PLANET_TRANDURH': 0.0,&#10;        'Relative_Error_PLANET_TRANMID': 0.0,&#10;        'Relative_Error_STAR_DIST': 0.0,&#10;        'Relative_Error_STAR_LOGG': 0.0,&#10;        'Relative_Error_STAR_PMDEC': 0.0,&#10;        'Relative_Error_STAR_PMRA': 0.0,&#10;        'Relative_Error_STAR_RAD': 0.0,&#10;        'Relative_Error_STAR_TEFF': 0.0,&#10;        'Relative_Error_STAR_TMAG': 0.0,&#10;        'koi_fittype_LS+MCMC': 1.0,&#10;        'koi_fittype_MCMC': 0.0,&#10;        'koi_fittype_none': 0.0&#10;    }&#10;    # Ensure all features are present and in correct order&#10;    input_df = pd.DataFrame([custom_input])[features]&#10;    pred = model.predict(input_df)&#10;    pred_label = le.inverse_transform([int(pred[0])])[0]&#10;    print(f&quot;Predicted label: {pred_label}&quot;)&#10;    assert pred_label in le.classes_&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>